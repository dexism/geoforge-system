### プロジェクトの概要

この「GeoForge System」は、毎回ユニークな架空世界のマップを生成するWebアプリケーションです。以下のステップで世界を構築していきます。

1.  **大陸生成**: ノイズ関数を用いて、地形、気候、植生などをリアルに生成します。
2.  **文明生成**: 生成された土地の「居住適性」に基づき、国家や集落（首都、都市、村など）を配置します。
3.  **経済シミュレーション**: 各地域での食料生産と消費を計算し、余剰や不足をシミュレートします。
4.  **インフラ（街道）生成**: 地形コストを考慮しながら、A*（エースター）アルゴリズムを用いて集落間を結ぶ合理的な街道網を構築します。
5.  **領土確定**: 街道網や集落の階層に基づき、各ヘックスがどの国家・領土に所属するかを最終決定します。
6.  **データ集計と可視化**: 全ての計算結果を統合し、D3.jsライブラリを用いてインタラクティブなヘックスマップとして描画します。

---

### 各モジュールの主な機能

#### 1. `continentGenerator.js` - 世界の土台を創る
Simplex-noiseというノイズ関数を巧みに利用して、リアルな大陸を生成します。
*   **地形と標高**: 大陸の形状、標高、内陸湖などを生成します。
*   **気候**: 緯度や標高を考慮して気温と降水量を計算し、「温暖湿潤気候」や「ツンドラ気候」など9種類の気候帯に分類します。
*   **水系**: 山岳地帯を水源とする河川をシミュレートし、低地へと流れる様子を再現します。
*   **植生と資源**: 気候や地形に基づき、「森林」「砂漠」「草原」などの植生を決定し、農業、林業、鉱業、漁業のポテンシャル値を各ヘックスに設定します。

#### 2. `civilizationGenerator.js` - 文明の灯をともす
生成された大陸に、人々が住み着き文明を築く過程をシミュレートします。
*   **居住適性の計算**: 農業適性、気温、資源などを総合的に評価し、人々が住みやすい土地を数値化します。
    *   **居住適性キャップ**: 居住適性が完全に1.0にならないよう、0.999でキャップします。
    *   **マップ端の抑制**: マップ端から5ヘックス以内の居住適性を減衰させ、端に都市が生成されるのを防ぎます。
    *   **人口のゆらぎ**: 最終的な人口計算にランダムな変動（0.85〜1.15倍）を加え、自然なばらつきを持たせます。
*   **国家の誕生**: 居住適性の高い土地に「首都」を配置し、国家を形成します。
*   **都市階層の構築**: 首都を中心に、「都市」「領都」「街」「町」「村」といった階層的な集落を、一定の距離を保ちながら配置していきます。
*   **領土の確定**: 各集落や空白地が、最終的にどの支配領域に属するかを決定します。

#### 3. `roadGenerator.js` - 人と物資の道をつなぐ
文明の動脈である街道網を、現実的な制約を考慮しながら構築します。
*   **コスト計算**: 地形の険しさ（標高、森林、河川など）に応じて「移動コスト」を設定します。
*   **A\*アルゴリズム**: 最短経路探索アルゴリズムを利用し、コストが最も低くなるように効率的なルートで集落間を結びます。
*   **階層的な街道網**:
    *   まず、主要都市間を「交易路」で結びます。
    *   次に、街や町から最寄りの上位都市や幹線道路へと道を延ばします。
    *   最後に、村々をクラスタ（グループ）にまとめ、代表地点から町へと道を接続します。
*   **親子関係の決定**: 街道網の接続に基づき、各集落がどの都市の支配下にあるか（`parentHexId`）を決定します。

#### 4. `economySimulator.js` - 人々の暮らしを支える
各地域の経済活動、特に食料需給をシミュレートします。
*   **食料生産**: 気候や土地の特性（河川沿いかなど）に応じて主要作物（小麦、稲など）を決定し、労働力やインフラのレベルを考慮して生産量を計算します。
*   **食料消費**: 集落の規模や種類に応じて、住民が必要とする食料の消費量を算出します。
*   **需給バランス**: 生産量と消費量を比較し、食料の余剰（`surplus`）または不足（`shortage`）を作物ごとに割り出します。
*   **領域データの集計**: 主要都市（首都、都市、領都）が庇護する領域全体の人口、農地面積、総生産量などを集計し、都市の持つ経済力を可視化します。

#### 5. `ui.js` - 世界をインタラクティブに描画する
シミュレーションによって生成された膨大なデータを、ユーザーが直感的に理解できるように可視化します。
*   **ヘックスマップ描画**: D3.jsを使い、全てのヘックスを地形や植生に応じた色で塗り分けます。
*   **レイヤー表示**: 国境線、河川、街道、各種オーバーレイ（気候帯、人口、農業適性など）をボタン一つで表示・非表示に切り替えられます。
*   **情報ウィンドウ**: ヘックスをクリックすると、座標、人口、気候、経済状況などの詳細なデータがフローティングウィンドウに表示されます。
*   **支配領域のハイライト**: 主要都市をクリックすると、その都市が支配下に置く全ての領土が階層に応じて色分けされ、勢力範囲が一目で分かります。

#### 6. `infoWindow.js` - 詳細情報の可視化
ユーザーがヘックスをクリックした際に表示される詳細情報ウィンドウのコンテンツを生成・管理します。
*   **情報カードの生成**: 基本情報、環境、資源、産業、領地管理といったカテゴリごとにカード形式で情報を整理して表示します。
*   **サイドバー統計の更新**: 画面左側のサイドバーに表示される、世界全体の人口や国家ごとの統計情報を集計・更新します。
*   **凡例の管理**: 気温、降水量、気候帯、人口分布、魔物ランクなどのオーバーレイ表示に対応した凡例を動的に生成します。

#### 7. `GeoForge Data API` (Google Apps Script) - データ連携と通知
Google Sheetsをバックエンドデータベースとして利用し、データの永続化と外部通知機能を提供します。
*   **データ保存**: 生成されたヘックスデータや道路データをGoogle SheetsにJSON形式で保存します。
*   **データ読み込み**: 保存されたデータを読み込み、アプリケーションの初期化時に復元します。
*   **Discord通知**: 「強制再生成」などの重要なイベントが発生した際に、DiscordのWebhookを通じて管理者に通知を送信します。

### 産業と経済
産業構造を区分。「魔法」「ギルド」「宗教」が各産業に深く関わり、産業間の結びつきが強い。

1. **第一次産業**: 資源を得る
2. **第二次産業**: 資源を加工する
3. **第三次産業**: 人にサービスを提供する
4. **第四次産業**: 知識と情報を扱う
5. **第五次産業**: 社会を統治・創造する

#### 1. 第一次産業 - 自然資源の獲得
*   **農業**: 麦・野菜・果樹・薬草栽培。魔法農法や精霊の加護で収穫量増加。
*   **牧畜**: 牛・羊・魔物など。乳製品や毛皮、魔獣素材の供給。
*   **漁業**: 川・湖・海での漁。漁師ギルドとの協力。
*   **採掘**: 鉱石・宝石・魔鉱石。鍛冶屋や魔導具師の基盤。
*   **林業**: 木材・薬木・魔樹。建築資材や魔法触媒。

#### 2. 第二次産業 - 加工・製造
*   **鍛冶・工房**: 武器防具、魔導具、生活道具。職人ギルドが中心。
*   **錬金術**: 薬品・ポーション・触媒の製造。素材は第一次産業から供給。
*   **建築**: 城・都市・村の建設。石工ギルドや魔法建築師。
*   **織物・染色**: 羊毛や麻、魔獣皮を加工。貴族向け衣装から冒険者装備まで。

#### 3. 第三次産業 - サービス
*   **商業**: 市場・行商・ギルドによる流通。交易路や港町が発展。
*   **宿泊・飲食**: 酒場・宿屋・料理店。冒険者の拠点。
*   **交通**: 馬車・船・飛竜便。安全な移動を提供。
*   **医療・癒し**: 僧侶・薬師・治癒師。ポーション販売や施術。
*   **教育**: 魔法学校・剣術道場。知識と技能の伝承。

#### 4. 第四次産業 - 知識・情報
*   **魔法研究**: 魔術ギルド、大学、賢者の塔。新しい呪文や魔導理論の開発。
*   **戦略・軍事学**: 王国軍や冒険者ギルドの戦術研究。
*   **学問**: 歴史学・地理学・神話研究。世界観の体系化。
*   **情報収集**: 占い師・予言者・諜報組織。未来予測や敵国情報。

#### 5. 第五次産業 - 統治・創造
*   **王政・貴族政治**: 国家運営、外交、税制。
*   **宗教・信仰**: 神殿・教会・司祭。精神的支柱と社会秩序。
*   **芸術・文化**: 吟遊詩人、劇団、画家。物語や伝承を広める。
*   **職能ギルド**: 依頼仲介、世界の安全保障。産業横断的な存在。
*   **創造的魔法**: 新しい世界観や文明を生み出す力。

---

### 技術仕様

#### WorldMap データ構造 (メモリ最適化)
v2.3.2より、メモリ使用量を削減するために `WorldMap` クラスのデータ構造を大幅に最適化しました。

*   **Structure of Arrays (SoA)**:
    各ヘックスのプロパティを個別のオブジェクトとして保持するのではなく、プロパティごとに型付き配列 (TypedArray) を用意し、全ヘックス分のデータを連続したメモリ領域に格納しています。これにより、メモリオーバーヘッドを最小限に抑えています。

*   **Flyweight パターン**:
    個々のヘックスを操作するための `Hex` オブジェクトは、アクセス時にオンデマンドで生成される軽量なラッパーです。これらは永続的にキャッシュされないため、大量のオブジェクトによるメモリ圧迫を防ぎます。

*   **データ型一覧**:

    | カテゴリ | プロパティ | データ型 | 説明 |
    | :--- | :--- | :--- | :--- |
    | **座標** | `col`, `row` | `Uint16Array` | 座標 (0-65535) |
    | **フラグ** | `isWater`, `isAlluvial`, `hasSnow` | `Uint8Array` | フラグ (0 or 1) |
    | **地形・気候** | `elevation` | `Int16Array` | 標高 (m) |
    | | `ridgeFlow` | `Int16Array` | 稜線流量 |
    | | `temperature`, `precipitation_mm`, `precipitation`, `climate`, `flow` | `Float32Array` | 気温, 降水量, 気候値, 流量などの浮動小数点数 |
    | **Enum ID** | `climateZoneId`, `vegetationId`, `terrainTypeId`, `settlementId`, `manaRankId`, `resourceRankId`, `monsterRankId`, `nationId`, `roadLevel` | `Uint8Array` | 各種区分のID (0-255) |
    | **ポテンシャル** | `manaValue`, `agriPotential`, `forestPotential`, `miningPotential`, `fishingPotential`, `huntingPotential`, `pastoralPotential`, `livestockPotential` | `Float32Array` | 各種適性値 (0.0-1.0など) |
    | **統計** | `cultivatedArea`, `habitability` | `Float32Array` | 耕作面積, 居住適性 |
    | | `population` | `Uint32Array` | 人口 (0-4,294,967,295) |
    | **参照・関係** | `parentHexId`, `territoryId` | `Int32Array` | 親ヘックスID, 領土ID (-1はnull) |
    | | `distanceToParent`, `travelDaysToParent` | `Float32Array` | 親への距離, 移動日数 |
    | | `neighborsBuffer` | `Int32Array` | 隣接ヘックスID (固定長6/hex) |
    | **複合データ** | `landUse_*` | `Float32Array` | 土地利用内訳 (river, desert, barren, grassland, forest) |
    | | `industry`, `production`, `surplus`, `shortage`, `territoryData` | `Array` | 複雑なオブジェクトを格納する疎な配列 (Sparse Array) |

# 地図仕様
- 地図のブロックは200km×200kmを横23ヘックス×縦20ヘックスで構成する。
- ブロックの周囲1ヘックスをオーバーラップ部として共有し、25×22ヘックスのデータを保持する。
- e値：00-24（00と24はオーバーラップ部として描画しない）
- n値：00-21（00と21はオーバーラップ部として描画しない）
- ブロックは`map_ee_nn.json`の命名規則で識別する。
- ブロック座標は`ee-nn`で表し、`ee`は経度方向、`nn`は緯度方向を表す。
- 赤道を`50`とし、赤道から北緯0.36度までのブロックを`51`とし、北緯89.64度から北極までのブロックを`99`とする。
- ブロックデータは、`public\map\`に保存する。
- 現在制作しているブロックは`map_48_71.json`から`map_52_75.json`までの25ブロックとする。
- マップデータのないブロック部は、ダミーの海洋データを生成して表示する。
- 起動時は`map_50_73.json`を読み込み、スクリーンの範囲により周囲のブロックを非同期に読み込む。
- この表示のため、117×102ヘックスのデータを作成し、25分割して`map_ee_nn.json`に保存する。
- ブロック内のヘックスのローカル座標は、`ee-nn`で表し、南西角を原点（`00-00`）として東、北へ増加する。
- ワールド座標として扱う場合、`map_50_73.json`ブロック（ブロック座標`50-73`）のローカル座標`12-08`のヘックスをワールド座標`5012-7308`と表す。
- 線形データ（道路、河川、稜線）は、ブロック単位で保存する。
- 道路パスは、集落から上位集落までの道のりとして保存するため、ブロック内の集落を起点とする道路パスをワールド座標として記憶する。
- 通商路は、首都を起点とした道路パスとして保存する。
- 稜線は、その都度計算して表示するため保存しない。
- 河川と道路は、画面表示用にブロック内の各ヘックス内に追加し、ブロックデータ（json）に保存する。
- 中心から各辺へのパスを６パターン、各辺から隣接辺への急カーブを６パターン、各辺から二つ目の辺への緩いカーブを６パターン、合計18パターンに道路レベルまたは河川幅を記憶させる。
- パターン0-5：中心からの直線、パターン6-11：中心をコントロールポイントとしたベジェ曲線（緩カーブ）、パターン12-17：共有頂点から半径2.885kmの120度円弧（急カーブ）とする。
- ヘックスのポイントとそれぞれの辺の名称は、中心：0、N：1、NE：2、SE：3、S：4、SW：5、NW：6とする。
- ヘックス内に同じパターンの道路が重なる場合は、より上位の道路のみを残す。
例）
```json
{
    "riverPath": [
        {
            "pattern": 0,
            "width": 0.5
        },{
            "pattern": 1,
            "width": 1.2
        }
    ],
    "roadPath": [
        {
            "pattern": 0,
            "level": 2
        },{
            "pattern": 1,
            "level": 3
        },{
            "pattern": 6,
            "level": 4
        }
    ]
}
```
# 画面描画
* **1. 基礎**
  * 座標は、x-yではなくe-nを使用する。
  * ブロック座標は`EE-NN`で表示する。`EE`は東に増加し、西に減少する2桁の数値で表す。`NN`は北に増加し、南に減少する2桁の数値とし、`50`を赤道から北緯1.8度の範囲とし`99`を北緯88.2度から北極までとする。赤道から極までを10,000kmとし、n座標`00`から`99`で全緯度をカバーする。
  * 1ブロックは、200 × 200kmのエリアとし、23列 × 20行のヘックスとする。
  * ブロック内の座標はローカル座標と言い、`ee-nn`で表す。`ee`は`01`から`23`まであり、データ上は前後の`00`、`24`を含んで記録される。`nn`は`01`から`20`まであり、データ上は前後の`00`、`21`を含んで記録される。
  * 全世界の一意のヘックスを示す座標をワールド座標と言い、ブロック座標とローカル座標を組み合わせて`EEee-NNnn`で表す。
  * 1ヘックスは、上下が辺の正六角形とし、対辺間のスケールは10km、面積は8660haとする。
  * 画面上の描画は、中心のワールド座標と縮尺で決まる。
  * 中心のワールド座標と縮尺により、画面内に標示すべきブロックを算出する。
  * 中心に近いブロックファイルから読み込み、表示させる。
  * ファイルが存在しない場合のみ、海洋のダミーデータを作成して表示する。ファイルが存在する場合はダミーデータは絶対に作成しない。
  * ヘックス表示色は、地形図色、レイヤー色の合成色とし、合成が完了したならばマップビュワーに「描画準備完了」を渡す。
  * マップビュワーは、描画準備完了したブロックから順に画面に表示する。
* **2. 初期画面**
  * 初期表示位置はワールド座標で指定し、`config.js`に記載する。
  * 初期縮尺は`config.js`に記載する。
  * 初期表示位置のワールド座標からブロックMapファイル名を決定し、ロードする。
  * 初期表示位置のワールド座標から周囲の表示エリア内のブロックMapファイル名を決定し、非同期でロードする。
* **3. ブロック表示**
  * ブロックMapファイル名を決定し、ロードする。
  * ロード時は表示を優先し手処理する。
  * レリーフ処理のため、北から南へ描画し、標高差を記憶してレリーフ濃度を逐次決定する。
  * 地形図表示には、標高、優勢植生、レリーフ濃度のデータを用いてカラーの合成を行う。
  * 砂浜、国境を描画する。
  * 人口データにより、「村・町・街・領都・都市・首都」の集落マーカーを表示する。
  * 道路、河川、稜線データにより道路、河川、稜線を描画する。（表示がONのもの）
  * 細部の植生割合や産業構造、社会構成などはクリック時に計算するためロード時には処置しない。
* **4. ダミー海洋データの生成**
**目的:** マップデータが存在しない領域（未生成エリア）であっても、座標表示やツールチップを機能させ、かつロード済み領域との境界で等高線が「海へ落ち込む」ように自然に閉じるさせるため。
**仕様:**
`setupUI`
  * 実行時に、ブロックファイルが存在しない（読込み前ではない。マップデータがサーバー上に存在しないことが確実なブロック）インデックスに対してダミーのオブジェクトを生成する。
  * **プロパティ:** elevation: 0 (海洋), terrainType: '海洋', isWater: true。
  * **表示色:** config.TERRAIN_COLORS['海洋'] に合わせる。
  * **オーバーラップ部の処理:** 隣接するマップデータのあるブロックデータから、隣接部のデータをコピーする。（列：00、01、20、21）（行：00、01、23、24）

# 等高線描画
**1. データ構造と描画ロジック**
## `hexes`配列の管理
* **全域確保:** `ui.js`のグローバル`hexes`配列は、マップ全体 (`config.COLS` x `config.ROWS`) のサイズで初期化される必要がある。これは `getIndex(col, row)`による一定のインデックスアクセスを保証するためである。
* **参照の維持:** 各ブロック (`blocks`配列内の要素) は、`block.allHexes`という配列を持ち、ここに`hexes`配列内のオブジェクトへの参照を格納している。
  * レンダリング関数 (`drawBlockContours`等) は`block.allHexes`を反復処理する。
  * したがって、動的にデータをロード・更新する際は、`hexes`配列内のオブジェクトを新しいオブジェクトで置換してはならない。置換すると`block.allHexes`内の参照が古いオブジェクト（ダミー等）を指したままとなり、描画に反映されない。
* **解決策:** 新しいデータで既存のオブジェクトのプロパティを上書き (Mutate) する`Object.assign`や個別代入を使用する。
## block 構造
* **Core Hexes:** そのブロックが「描画責任を持つ」領域 (23x20)。クリップパスにより、この領域外の描画はカットされる。
* **All Hexes (Buffer):** 等高線計算に必要な、隣接データを含む領域 (25x22)。隣接ブロックのデータを参照することで、ブロック境界の等高線が滑らかに接続される。

**2. 動的ロードと補間**
* **問題（カクつき）:** 動的にロードされたブロックで、隣接データがメモリ上（hexes）に存在しない場合、補間ロジックが自身の値やデフォルト値を参照し、等高線がブロック端で途切れたり、四角形になったりする。
* **解決策:**
  * ブロックロード時に、そのブロックおよびバッファ領域（Col: 0, 24 / Row: 0, 21部分）のデータを`hexes`配列に反映する。
  * 反映時は前述の通り、オブジェクトの`Mutation`を行う。

# 大陸生成

## 1. 地形の決定
- 大陸生成時に一度だけ実施する。
- 複数のノイズにより各ヘックスの**標高**を決定する。
- 各ヘックスの標高と隣接ヘックスの標高により、**地形区分**と**平坦度**を決定する。

## 2. 気候の決定
- 大陸生成時に一度だけ実施する。
1. 各ヘックスの**年間降水量**と**年平均気温（標高補正済み）**を決定する。
2. 各ヘックスの**気候帯**を決定する。

**参考コード**
必要により適切なノイズを含めること。
```JavaScript
/**
 * GeoForge System: 12気候区分判定
 * 入力は「高度補正済みの年平均気温 T [°C]」「年間降水量 P [mm]」「標高 H [m]」
 * 出力は以下の12区分のいずれかの文字列:
 * - "氷雪気候"
 * - "ツンドラ気候"
 * - "亜寒帯湿潤気候"
 * - "亜寒帯乾燥気候"
 * - "ステップ気候"
 * - "砂漠気候(寒)"
 * - "砂漠気候(熱)"
 * - "地中海性気候"
 * - "温暖湿潤気候"
 * - "亜熱帯湿潤気候"
 * - "熱帯草原気候"
 * - "熱帯雨林気候"
 *
 * 判定方針（最小構成・月別データ不要）:
 * 1) 標高で高山/氷雪を優先判定（森林限界や氷雪域）
 * 2) 気温で寒帯・亜寒帯・温帯・亜熱帯/熱帯の帯域を決定
 * 3) 乾燥限界（簡易式）で乾燥帯（砂漠/ステップ）を判定
 * 4) 湿潤帯は降水量の閾値で温帯/亜熱帯/熱帯のサブタイプを割り当て
 */

function classifyClimate(T_mean, P_annual, H_m) {
  // ------------- 調整可能な閾値（世界観チューニング用） -------------
  const H_ice = 3600;     // 氷雪域の標高（m）: 高山・寒冷地での氷雪気候
  const H_alpine = 3000;  // 森林限界の代表値（m）: これ以上は樹木生育が困難（ツンドラ相当）

  // 乾燥限界（ケッペン準拠の簡易形）
  // 季節性を持たない最小構成として、定数オフセットC=140を採用（中庸）
  // Rbが高いほど乾燥閾が厳しくなり、乾燥帯の判定を避けやすい。
  const C = 140;
  const Rb = 20 * T_mean + C; // 乾燥限界（mm）

  // 熱帯・温帯・亜熱帯の湿潤/雨林判定用の基準値（目安）
  const P_rainforest = 2000;   // 熱帯雨林の代表閾（mm）
  const P_humid = 800;         // 温帯湿潤/亜熱帯湿潤の下限（mm）
  const P_mediterranean_upper = 700; // 地中海性の年降水量上限（mm）目安
  const P_steppe_low = Math.max(250, 0.5 * Rb); // ステップ下限の目安（安全側）

  // ------------- 1) 標高優先の寒冷域判定 -------------
  if (H_m >= H_ice || T_mean < -5) {
    return "氷雪気候";
  }
  if (H_m >= H_alpine || T_mean < 0.5) {
    // 森林限界以上 or 非常に低温 → ツンドラ
    return "ツンドラ気候";
  }

  // ------------- 2) 乾燥帯（砂漠/ステップ）判定 -------------
  // 乾燥帯の入口は年降水量と乾燥限界の比較で決定
  if (P_annual < 0.5 * Rb) {
    // 砂漠（熱/寒）は年平均気温で分岐
    return T_mean >= 18 ? "砂漠気候(熱)" : "砂漠気候(寒)";
  }
  if (P_annual < Rb) {
    return "ステップ気候";
  }

  // ------------- 3) 帯域（熱帯/亜熱帯/温帯/亜寒帯）と湿潤タイプ -------------
  // 亜寒帯（冷帯）: 寒冷な温帯の上位
  if (T_mean < -3) {
    // すでにツンドラ/氷雪でない寒冷湿潤域
    // 年降水量が乾燥限界以上なら湿潤、それ未満寄りなら乾燥
    return P_annual >= Rb ? "亜寒帯湿潤気候" : "亜寒帯乾燥気候";
  }

  // 温帯域（基準）
  if (T_mean >= -3 && T_mean < 18) {
    // 地中海性候補：温帯で比較的少雨（乾燥帯には入らない）
    if (P_annual <= P_mediterranean_upper && P_annual >= 0.5 * Rb) {
      return "地中海性気候";
    }
    // 十分湿潤なら温暖湿潤
    if (P_annual >= P_humid) {
      return "温暖湿潤気候";
    }
    // 湿潤下限に満たないが乾燥帯ではない場合は、温帯の中庸を温暖湿潤に吸収
    return "温暖湿潤気候";
  }

  // 亜熱帯・熱帯域（高温側）
  if (T_mean >= 18 && T_mean < 24) {
    // 乾燥帯に該当しない前提で、湿潤なら亜熱帯湿潤、比較的少雨なら熱帯草原に近い
    if (P_annual >= P_humid) {
      return "亜熱帯湿潤気候";
    }
    // 湿潤下限に満たないが乾燥帯ではない → 熱帯草原寄り
    return "熱帯草原気候";
  }

  // 熱帯（高温・多雨）
  if (T_mean >= 24) {
    // 多雨なら熱帯雨林、そうでなければ熱帯草原
    if (P_annual >= P_rainforest) {
      return "熱帯雨林気候";
    }
    return "熱帯草原気候";
  }

  // 万一のフォールバック（理論上到達しない）
  return "温暖湿潤気候";
}

// -------------- 例: テスト --------------
// console.log(classifyClimate(25, 2200, 50));   // 熱帯雨林気候
// console.log(classifyClimate(21, 1200, 100));  // 亜熱帯湿潤気候
// console.log(classifyClimate(12, 600, 200));   // 地中海性気候（温帯・少雨）
// console.log(classifyClimate(5, 900, 100));    // 温暖湿潤気候
// console.log(classifyClimate(-1, 700, 50));    // 亜寒帯湿潤気候
// console.log(classifyClimate(10, 300, 50));    // ステップ気候（乾燥）
// console.log(classifyClimate(16, 150, 50));    // 砂漠気候(寒)
// console.log(classifyClimate(28, 100, 50));    // 砂漠気候(熱)
// console.log(classifyClimate(-6, 500, 200));   // 氷雪気候
// console.log(classifyClimate(1, 500, 3200));   // ツンドラ気候（高標高）
```

## 3. 各ヘックスの保水力を決定する。

  **3.1. 地形：地形保水基準**
    - 深海：-
    - 海洋：-
    - 湖沼：-
    - 平地：0.60
    - 丘陵：0.50
    - 山地：0.40
    - 山岳：0.30

  **3.2. 気候区分：気候保水基準：蒸発散係数**
    - 砂漠気候(寒)：0.1：0.85
    - ツンドラ気候：0.35：0.55
    - 亜寒帯湿潤気候：0.65：0.40
    - ステップ気候：0.25：0.75
    - 地中海性気候：0.55：0.55
    - 温暖湿潤気候：0.65：0.45
    - 砂漠気候(熱)：0.08：0.95
    - 熱帯草原気候：0.40：0.65
    - 熱帯雨林気候：0.75：0.35
    - 亜熱帯湿潤気候：0.60：0.50
    - 亜寒帯乾燥気候：0.30：0.70
    - 氷雪気候：0.12：0.80

  **3.3. 保水力の算定式**
  `保水力 = clip01((0.6 * 地形保水基準 + 0.4 * 気候保水基準) * (1 - 0.7 * 蒸発散係数))`

## 4. 河川の生成
- 水源発生確率から水源地を決定し、低いほうへ河川を繋げていく。
- 海に出るか、それ以上低い場所がなくなったら終了する。

  **4.1. 河川データ構造**
```json
{
  "河川":{
    "流入":[ // 複数方向からの流入あり
      {
        "方向":0, // 0:水源
        "水量":0.5, // 水源における初期値 = 保水力
        "川幅":1 // 描画のために必要
      },{
        "方向":2,
        "水量":1.0,
        "川幅":2
      }
    ],
    "流出方向":5
  }
}
```

  **4.2. 水源の生成**
    - 各ヘックスの水源を参考コードにより決定する。
    - 水源となったヘックスの初期水量を決定する。（水源における初期水量 = 保水力）
    - 

  **4.3. 参考コード**
```JavaScript
// 水源発生確率を計算する関数
// 入力: 標高 E [m], 降水量 P [mm], 保水力 R [0..1]
// 出力: 0..1 の確率
function waterSourceProbability(E, P, R, {
  Emax = 4500,   // 最大標高 [m]
  P_half = 800,  // 降水量の半飽和定数 [mm]
  alpha = 1.2,   // 降水の閾値強調係数
  beta = 0.7     // 標高寄与の指数
} = {}) {
  const clip01 = x => Math.max(0, Math.min(1, x));

  // 標高の正規化と源頭寄与
  const E_norm = clip01(E / Emax);
  const E_src = Math.pow(E_norm, beta); // 標高寄与

  // 降水の飽和（ミカエリス・メンテン型）
  const P_eff = P / (P + P_half);

  // 保水・標高のブースト因子（0.5〜1.0, 0.4〜1.0）
  const retentionBoost = 0.5 + 0.5 * R;
  const elevationBoost = 0.4 + 0.6 * E_src;

  // 最終確率
  const prob = Math.pow(P_eff, alpha) * retentionBoost * elevationBoost;
  return clip01(prob);
}

// 例: 標高 1200m, 降水 900mm, 保水力 0.43
const p = waterSourceProbability(1200, 900, 0.43);
console.log(p); // 0..1 の値を返す
```

## 3. 河川を生成する。

### 河川水域算定アルゴリズム
- 水域面積の算定方法を具体化します。
- 各ヘックスの面積は8660ha、対辺間距離は10kmです。
- 区間流線長は、どの辺からどの辺へ流れたかにより決まります。
- 対辺間を流れる場合の直線距離は10km、隣接辺へ流れ出る場合の直線距離は5km、2つ目の辺へ流れ出る場合の直線距離は8.66km、水源地の場合は5km、これに上流と下流の高低差と平坦度を使って蛇行度を見積り、実流水区間長(km)を決定します。
- 流量は、水源地ヘックスから流れ出る流量を0.5㎥/sとし、各ヘックスは上流側の辺（流入辺）流量（複数の進入部がある場合は当該ヘックスで合流する）に保水力と降水量による基本増加量を加算し、下流側の辺（流出辺）流量を求めます。
- 各ヘックスは、流量と高低差、実流水区間長から流速、断面を決定し水域面積を出力します。

```JavaScript
/**
 * 水域面積算定
 * 入力: 流入流量 Qin [m3/s], 降水量 P [mm], 保水力 R [0..1],
 *       高低差 dH [m], 平坦度 flatness [0..1],
 *       流線タイプ type ("opposite","adjacent","second","source")
 * 出力: 水域面積 [ha]
 */

function calcWaterArea({
  Qin, P, R, dH, flatness, type
}) {
  const clip01 = x => Math.max(0, Math.min(1, x));

  // --- 区間直線距離 ---
  let L_straight = 10;
  if (type === "adjacent") L_straight = 5;
  else if (type === "second") L_straight = 8.66;
  else if (type === "source") L_straight = 5;

  // --- 蛇行度補正 ---
  const meanderFactor = 1 + (dH / 1000) * (1 - flatness);
  const L_actual = L_straight * meanderFactor; // km

  // --- 流量計算 ---
  const k = 0.00005; // 調整係数
  const dQ = k * P * R; // 降水・保水寄与
  const Qout = Qin + dQ;

  // --- 流速・断面 ---
  // 幅は平坦度に比例 (10–100m)
  const width = 10 + 90 * flatness;
  // 水深は流量と高低差から近似
  const depth = Math.max(0.5, (Qout / 5) + dH / 500);
  const A = width * depth; // m2

  const v = Qout / A; // m/s

  // --- 水域面積算定 ---
  // 区間長[km] → m に変換
  const WaterArea_m2 = (L_actual * 1000) * width;
  const WaterArea_ha = WaterArea_m2 / 10000;

  return {
    L_actual_km: L_actual,
    Qout,
    v,
    width,
    depth,
    WaterArea_ha
  };
}

// --- 使用例 ---
const result = calcWaterArea({
  Qin: 0.5, P: 900, R: 0.43,
  dH: 50, flatness: 0.6, type: "opposite"
});

console.log(result);
```

```JavaScript
/**
 * 河口・デルタ向け水域面積算定（タイプ別に分離）
 * 入力:
 *  - hexHa: ヘックス面積[ha]
 *  - L_km: 実流長[km]（河口でも8.66〜10を採用可）
 *  - Q: 累積流量[m3/s]
 *  - flatness[0..1], oceanicity[0..1], R[0..1] 保水力
 *  - tidalRange[m] 潮汐レンジ（例：1〜4m）
 *  - isRiverMouth: 河口フラグ
 * 出力: { channelHa, deltaHa, marshHa, lagoonHa, waterTotalHa }
 */
function waterAreasRiverMouth({
  hexHa = 8660,
  L_km = 8.66,
  Q,
  flatness,
  oceanicity,
  R,
  tidalRange = 2.0,
  isRiverMouth = false
}) {
  const clip01 = x => Math.max(0, Math.min(1, x));
  const L_m = L_km * 1000;

  // 幅・深さの経験式（初期係数）
  const a = 2.5, b = 0.5;     // w = a * Q^b
  const c = 0.25, f = 0.4;    // d = c * Q^f
  const w_m = Math.max(15, a * Math.pow(Q, b));
  const d_m = Math.max(1.0, c * Math.pow(Q, f));

  // 河道面積
  const channelHa_raw = (L_m * w_m) / 1e4;

  // 河口・デルタ拡張係数
  const tideFactor = clip01(tidalRange / 3.0);               // 0〜1
  const flatWet = clip01(0.6 * flatness + 0.4 * R);          // 0〜1
  const coastFactor = clip01(oceanicity);                     // 0〜1

  // デルタ・干潟面積（河道の数倍に拡張）
  // 河口なら強化、内陸なら抑制
  const deltaMultiplier = isRiverMouth
    ? 1.0 + 4.0 * (0.5 * tideFactor + 0.3 * flatWet + 0.2 * coastFactor)
    : 0.5 + 1.0 * flatWet;

  const deltaHa_raw = channelHa_raw * deltaMultiplier;

  // 湿地（塩湿地・感潮湿地）
  const marshHa_raw = channelHa_raw * (0.8 + 2.5 * flatWet) * (0.5 + 0.5 * coastFactor);

  // 潟湖（lagoon）：潮汐＋海洋性が高く、平坦で保水力が高いほど成立
  const lagoonFrac = isRiverMouth ? 0.05 + 0.25 * (0.4 * tideFactor + 0.4 * coastFactor + 0.2 * flatWet) : 0;
  const lagoonHa_raw = hexHa * lagoonFrac;

  // 上限（cap）
  const channelCapFrac = isRiverMouth ? 0.20 : 0.10;  // 河道の面積上限
  const deltaCapFrac   = isRiverMouth ? 0.60 : 0.20;  // デルタ・干潟の上限
  const marshCapFrac   = isRiverMouth ? 0.50 : 0.30;  // 湿地の上限
  const lagoonCapFrac  = isRiverMouth ? 0.40 : 0.10;  // 潟湖の上限
  const totalCapFrac   = isRiverMouth ? 0.95 : 0.50;  // 総水域の上限

  let channelHa = Math.min(channelHa_raw, hexHa * channelCapFrac);
  let deltaHa   = Math.min(deltaHa_raw,   hexHa * deltaCapFrac);
  let marshHa   = Math.min(marshHa_raw,   hexHa * marshCapFrac);
  let lagoonHa  = Math.min(lagoonHa_raw,  hexHa * lagoonCapFrac);

  // 総面積の上限調整（超過時は比率で縮小）
  let waterTotalHa = channelHa + deltaHa + marshHa + lagoonHa;
  const maxTotal = hexHa * totalCapFrac;
  if (waterTotalHa > maxTotal) {
    const scale = maxTotal / waterTotalHa;
    channelHa *= scale; deltaHa *= scale; marshHa *= scale; lagoonHa *= scale;
    waterTotalHa = maxTotal;
  }

  return {
    channelHa: Math.round(channelHa),
    deltaHa: Math.round(deltaHa),
    marshHa: Math.round(marshHa),
    lagoonHa: Math.round(lagoonHa),
    waterTotalHa: Math.round(waterTotalHa)
  };
}
```

## 4. 植生を決定する。

### 植生区分
- 砂漠：乾燥地帯、農耕不可、交易路・鉱物資源に強み。乾燥指標が高、肥沃度低、平坦でも可
- ステップ：乾燥草原、遊牧・交易路に強み、農耕は限定的。乾燥指標中、肥沃度中、火事係数中
- サバンナ：疎林草原、牧畜・狩猟・交易に適する。高温＋中乾燥、火事係数高、土壌水分保持は中
- 草原：農耕・牧畜両立、交通容易、人口集積に適する。温帯/亜寒帯＋中降水、肥沃度高、排水良好
- 温帯林：四季変化、木材・狩猟資源豊富、農耕と共存可能。温帯＋降水充分、肥沃度中～高、排水中
- 亜寒帯林：タイガ、針葉樹中心、木材・毛皮資源、農耕制約あり。低温＋降水充分、標高高め
- 熱帯雨林：高生産性だが伐採困難、果実・薬草・病害リスク大。高温＋高降水、排水過剰でなく、火事係数低
- 湿地：農耕困難だが魚介・薬草資源豊富、交通制約大。低平坦度＋高水域近接＋排水不良/氾濫高
- 沿岸植生：海岸砂丘・マングローブ・潮間帯、漁業・塩資源・港湾立地に直結。海岸近接（距岸距離の減衰）
- ツンドラ：寒帯草原、苔・低木主体、農耕不可、狩猟・遊牧中心。最暖期低温＋高標高/高緯度、土壌凍結（代替に低温で代用）
- アルパイン（高山植生）：森林限界上、低木・草本主体、資源乏しいが鉱物・水源あり。標高森林限界超過
- 荒れ地：半乾燥・痩せ地、低生産性だが鉱物・放牧に利用可能。低肥沃度＋高傾斜（平坦度低）＋降水不足（乾燥では砂漠未満の荒地）
- 氷雪帯：高標高＋低温、植物はなく氷雪覆われた地形

### 植生区分判定のためのパラメータ
- 年平均気温
- 年間降水量
- 標高
- 海洋/湖沼/河川水域面積
- 地形平坦度（隣接ヘックス標高、稜線レベル）
- 土壌肥沃度：0–1
- 乾燥指数：年間降水量 / (20 * 年平均気温 + 140)
- 距岸距離（海からの距離）／海洋性係数

**参考コード**
植生分布は毎起動時に計算するため、ノイズを含めない。

**保水力を組み込んだ植生分布計算コード**
```JavaScript
/**
 * 植生分布計算（保水力を含む）
 * 入力: 年平均気温 T [°C], 
 *       年間降水量 P [mm], 
 *       標高 H [m],
 *       水域面積 waterHa [ha], 
 *       平坦度 flatness [0–1],
 *       土壌肥沃度 soilFert [0–1], 
 *       乾燥指数 D,
 *       距岸距離 coastalDist [km], 
 *       海洋性係数 oceanicity [0–1],
 *       保水力 R [0–1]
 * 出力: 各植生区分の面積 [ha]
 */

function allocateVegetation({
  T, P, H, waterHa,
  flatness, soilFert, D,
  coastalDist, oceanicity,
  R // 保水力
}) {
  const hexAreaHa = 8660;
  const landHa = Math.max(0, hexAreaHa - waterHa);

  // 適性スコア初期化
  const s = {
    desert: 0, wasteland: 0, grassland: 0, wetland: 0,
    temperateForest: 0, subarcticForest: 0, tropicalRainforest: 0,
    alpine: 0, tundra: 0, savanna: 0, steppe: 0, coastal: 0,
    iceSnow: 0
  };

  // --- 植生適性スコア計算 ---
  // 氷雪帯: 高標高 or 極低温
  if (T <= -5 || H >= 4000) {
    s.iceSnow = 1.2;
  }

  // 砂漠: 乾燥指数 <0.5
  if (D < 0.5 && s.iceSnow === 0) {
    s.desert = (0.5 - D) * (T >= 18 ? 1.0 : 0.7) * (1 - R);
  }

  // 荒れ地: 土壌肥沃度が低い & 降水不足
  if (soilFert < 0.3 && P < 400) {
    s.wasteland = 0.6 * (1 - 0.5 * R);
  }

  // 草原: 中程度の降水 & 平坦度高
  if (D >= 1 && P >= 400 && P < 1200) {
    s.grassland = 0.7 * flatness * (0.5 + 0.5 * R);
  }

  // 湿地: 平坦度高 & 排水不良
  if (flatness > 0.7 && (P > 1200 || oceanicity > 0.6)) {
    s.wetland = 0.8 * (0.5 + 0.5 * R);
  }

  // 温帯林: T 5–18℃ & P充分
  if (T >= 5 && T < 18 && P >= 800) {
    s.temperateForest = 0.8 * soilFert * (0.5 + 0.5 * R);
  }

  // 亜寒帯林: T -3〜5℃ & P充分
  if (T >= -3 && T < 5 && P >= 600) {
    s.subarcticForest = 0.7 * (0.5 + 0.5 * R);
  }

  // 熱帯雨林: T ≥24℃ & P ≥2000
  if (T >= 24 && P >= 2000) {
    s.tropicalRainforest = 0.9 * (0.5 + 0.5 * R);
  }

  // アルパイン: 標高 ≥3000m
  if (H >= 3000 && s.iceSnow === 0) {
    s.alpine = 1.0 * (0.5 + 0.5 * R);
  }

  // ツンドラ: T <2℃ または 標高 ≥2400m
  if ((T < 2 || H >= 2400) && s.iceSnow === 0) {
    s.tundra = 0.7 * (0.5 + 0.5 * R);
  }

  // サバンナ: T ≥18℃ & D 0.5–1
  if (T >= 18 && D >= 0.5 && D < 1) {
    s.savanna = 0.6 * (0.7 + 0.3 * R);
  }

  // ステップ: D 0.5–1 & P <800
  if (D >= 0.5 && D < 1 && P < 800) {
    s.steppe = 0.6 * (1 - 0.5 * R);
  }

  // 沿岸植生: 海岸近接
  if (coastalDist < 20 || oceanicity > 0.7) {
    s.coastal = 0.7 * (0.5 + 0.5 * R);
  }

  // --- 正規化して面積配分 ---
  const sum = Object.values(s).reduce((a, b) => a + b, 0);
  const areas = {};
  if (sum === 0) {
    areas.grassland = landHa; // フォールバック
  } else {
    for (const [k, v] of Object.entries(s)) {
      areas[k] = Math.round((v / sum) * landHa);
    }
  }
  areas.water = waterHa;

  return areas;
}

// --- 使用例 ---
const result = allocateVegetation({
  T: 22, P: 900, H: 1200,
  waterHa: 200, flatness: 0.6,
  soilFert: 0.5, D: 900 / (20 * 22 + 140),
  coastalDist: 30, oceanicity: 0.4,
  R: 0.43 // 保水力
});

console.log(result);
```

**野菜の扱いの考え方**
穀物・稲作が主にカロリー基盤を担うのに対し、野菜は微量栄養素・食味・季節多様性を担うため、面積・収量・季節性・水需要・労働集約度の扱いを分けると現実的になります。大規模畑の「主要食糧」ではなく、近接立地の「集約園芸」としてモデル化するのが自然です。
- 役割: カロリー補助ではなく、栄養補完と市場価値。
- 立地: 集落近接、用水近接（灌漑/井戸）を強く要求。
- 季節性: 複数回収穫（継ぎ作/輪作）・短い栽培期間。
- 労働: 高い労働集約度（面積当たり労働日が穀物の2〜5倍）。
- 水: 高水需要（干ばつに脆弱）、保水力・用水が面積上限を規定。
- 保存: 高い生鮮比率、保存損失（漬物・乾燥で損失軽減パラメータ）。

**区分とパラメータ設計**
- 葉菜類: 高水・短期・多収だが保存弱。例：葉物（春秋）。
- 根菜類: 中水・中期・保存良。例：ダイコン、ニンジン（秋～冬）。
- 果菜類: 高水・温暖期・市場向け。例：ナス、キュウリ（夏）。
- 豆類（菜豆・莢豆）: 中水・窒素寄与・保存中。例：インゲン。

**各区分に以下のパラメータを持たせると運用しやすい**
- 収量/収穫回数: 1収穫あたりの収量と年間収穫回数（succession）。
- 栽培必要面積/人: 食事構成に応じた標準面積（穀物より小さく）。
- 水需要係数: 灌漑・保水力に対する面積上限補正。
- 労働日/ha: 面積あたり労働負荷。
- 保存損失率: 収穫後の季節別損失。
- 季節ウィンドウ: 作付可能月（地域の気温帯で切替）。

**面積配分ロジック**
- 近接制約: 集落半径X km以内、または用水半径Y km以内のみ野菜面積を許可。
- 用水・保水上限: 可耕地のうち、保水力Rと用水（河川/井戸）に比例した上限を設定。
- 季節スロット: 年間スロット（春・夏・秋・冬）に作付し、重複可能（継ぎ作）。
- 食事構成: 穀物の必要面積を満たした後、野菜面積を「栄養枠（例：0.03–0.08ha/人）」として配分。
- 市場需要: 都市近傍では面積を拡張（価格係数）、農村では栄養枠中心。

**データ定義の例**
```javascript
export const CROP_DATA = {
  // 既存
  '小麦': { yield: 0.60, type: '畑作', cultivation_ha_per_person: 1.5 },
  '大麦': { yield: 0.75, type: '畑作', cultivation_ha_per_person: 1.5 },
  '雑穀': { yield: 0.65, type: '畑作', cultivation_ha_per_person: 1.5 },
  '稲':   { yield: 1.35, type: '水田', cultivation_ha_per_person: 0.8 },
  '果物': { yield: 0.80, type: '樹園', cultivation_ha_per_person: 1.0 },

  // 野菜（区分別に代表値）
  '葉菜類': {
    type: '園芸',
    yield_per_harvest: 4.0,        // t/ha/回（生鮮重量）
    harvests_per_year: 2,          // 春・秋の2回（地域で可変）
    cultivation_ha_per_person: 0.015, // 標準食構成での目安
    water_demand: 0.8,             // 0..1（高水需要）
    labor_days_per_ha: 80,         // 労働集約
    storage_loss_frac: 0.35,       // 生鮮消費中心
    season_windows: ['spring','autumn']
  },
  '根菜類': {
    type: '園芸',
    yield_per_harvest: 6.0,        // t/ha/回
    harvests_per_year: 1,
    cultivation_ha_per_person: 0.02,
    water_demand: 0.6,
    labor_days_per_ha: 60,
    storage_loss_frac: 0.15,       // 保存良
    season_windows: ['autumn','winter']
  },
  '果菜類': {
    type: '園芸',
    yield_per_harvest: 5.0,
    harvests_per_year: 1,
    cultivation_ha_per_person: 0.02,
    water_demand: 0.9,
    labor_days_per_ha: 90,
    storage_loss_frac: 0.30,
    season_windows: ['summer']
  },
  '豆類（菜豆）': {
    type: '園芸',
    yield_per_harvest: 2.5,         // 生鮮換算
    harvests_per_year: 1,
    cultivation_ha_per_person: 0.01,
    water_demand: 0.5,
    labor_days_per_ha: 50,
    storage_loss_frac: 0.20,
    nitrogen_credit: 0.1,           // 土壌窒素への貢献（肥沃度補正）
    season_windows: ['summer','autumn']
  }
};
```
**面積配分の実務ルール**
- 最低栄養枠: 人口×0.03〜0.08haを野菜枠として確保（都市は上振れ）。
- 近接制約: 集落中心から半径2km以内、用水半径1km以内のみ野菜面積を計上。
- 水制約: 野菜枠のうち灌漑なし面積は R に比例して上限設定（例：max_frac = 0.3 + 0.5R）。
- 輪作: 豆類の nitrogen_credit を肥沃度へ年次加算し、穀物収量に小幅反映。
- 季節損失: storage_loss_frac を季節在庫へ適用、加工（漬物/乾燥）で損失低減フラグを用意。

**直感的な初期値の目安**
- 野菜の標準面積/人: 0.03–0.05ha（灌漑ありで下限寄り、なしで上限寄り）。
- 都市近郊: 市場需要係数で×1.5〜2.0、ただし用水・保水制約を強く適用。
- 日本の温帯域想定: 葉菜2回、根菜1回、果菜1回の複合作で年間供給を安定化。

**収量計算の例（野菜の季節・用水補正）**
```javascript
/**
 * 野菜の年間実収量（t/ha）を計算
 * 入力: 作物データ、保水力R、灌漑可否hasIrrigation、気温帯band('寒','温','亜熱','熱')
 * 出力: 年間実収量 t/ha
 */
export function vegetableAnnualYield(cropKey, { R, hasIrrigation, band }) {
  const c = CROP_DATA[cropKey];
  if (!c || c.type !== '園芸') return 0;

  const waterLimit = hasIrrigation ? 1.0 : Math.min(1.0, 0.6 + 0.5 * R * c.water_demand);
  const climateFactor = (() => {
    switch (band) {
      case '寒': return 0.7;
      case '温': return 1.0;
      case '亜熱': return 1.1;
      case '熱': return cropKey === '根菜類' ? 0.9 : 1.2;
      default: return 1.0;
    }
  })();

  const perHarvest = c.yield_per_harvest * waterLimit * climateFactor;
  return perHarvest * c.harvests_per_year;
}
```
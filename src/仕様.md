### プロジェクトの概要

この「GeoForge System」は、毎回ユニークな架空世界のマップを生成するWebアプリケーションです。以下のステップで世界を構築していきます。

1.  **大陸生成**: ノイズ関数を用いて、地形、気候、植生などをリアルに生成します。
2.  **文明生成**: 生成された土地の「居住適性」に基づき、国家や集落（首都、都市、村など）を配置します。
3.  **経済シミュレーション**: 各地域での食料生産と消費を計算し、余剰や不足をシミュレートします。
4.  **インフラ（街道）生成**: 地形コストを考慮しながら、A*（エースター）アルゴリズムを用いて集落間を結ぶ合理的な街道網を構築します。
5.  **領土確定**: 街道網や集落の階層に基づき、各ヘックスがどの国家・領土に所属するかを最終決定します。
6.  **データ集計と可視化**: 全ての計算結果を統合し、D3.jsライブラリを用いてインタラクティブなヘックスマップとして描画します。

---

### 各モジュールの主な機能

#### 1. `continentGenerator.js` - 世界の土台を創る
Simplex-noiseというノイズ関数を巧みに利用して、リアルな大陸を生成します。
*   **地形と標高**: 大陸の形状、標高、内陸湖などを生成します。
*   **気候**: 緯度や標高を考慮して気温と降水量を計算し、「温暖湿潤気候」や「ツンドラ気候」など9種類の気候帯に分類します。
*   **水系**: 山岳地帯を水源とする河川をシミュレートし、低地へと流れる様子を再現します。
*   **植生と資源**: 気候や地形に基づき、「森林」「砂漠」「草原」などの植生を決定し、農業、林業、鉱業、漁業のポテンシャル値を各ヘックスに設定します。

#### 2. `civilizationGenerator.js` - 文明の灯をともす
生成された大陸に、人々が住み着き文明を築く過程をシミュレートします。
*   **居住適性の計算**: 農業適性、気温、資源などを総合的に評価し、人々が住みやすい土地を数値化します。
    *   **居住適性キャップ**: 居住適性が完全に1.0にならないよう、0.999でキャップします。
    *   **マップ端の抑制**: マップ端から5ヘックス以内の居住適性を減衰させ、端に都市が生成されるのを防ぎます。
    *   **人口のゆらぎ**: 最終的な人口計算にランダムな変動（0.85〜1.15倍）を加え、自然なばらつきを持たせます。
*   **国家の誕生**: 居住適性の高い土地に「首都」を配置し、国家を形成します。
*   **都市階層の構築**: 首都を中心に、「都市」「領都」「街」「町」「村」といった階層的な集落を、一定の距離を保ちながら配置していきます。
*   **領土の確定**: 各集落や空白地が、最終的にどの支配領域に属するかを決定します。

#### 3. `roadGenerator.js` - 人と物資の道をつなぐ
文明の動脈である街道網を、現実的な制約を考慮しながら構築します。
*   **コスト計算**: 地形の険しさ（標高、森林、河川など）に応じて「移動コスト」を設定します。
*   **A\*アルゴリズム**: 最短経路探索アルゴリズムを利用し、コストが最も低くなるように効率的なルートで集落間を結びます。
*   **階層的な街道網**:
    *   まず、主要都市間を「交易路」で結びます。
    *   次に、街や町から最寄りの上位都市や幹線道路へと道を延ばします。
    *   最後に、村々をクラスタ（グループ）にまとめ、代表地点から町へと道を接続します。
*   **親子関係の決定**: 街道網の接続に基づき、各集落がどの都市の支配下にあるか（`parentHexId`）を決定します。

#### 4. `economySimulator.js` - 人々の暮らしを支える
各地域の経済活動、特に食料需給をシミュレートします。
*   **食料生産**: 気候や土地の特性（河川沿いかなど）に応じて主要作物（小麦、稲など）を決定し、労働力やインフラのレベルを考慮して生産量を計算します。
*   **食料消費**: 集落の規模や種類に応じて、住民が必要とする食料の消費量を算出します。
*   **需給バランス**: 生産量と消費量を比較し、食料の余剰（`surplus`）または不足（`shortage`）を作物ごとに割り出します。
*   **領域データの集計**: 主要都市（首都、都市、領都）が庇護する領域全体の人口、農地面積、総生産量などを集計し、都市の持つ経済力を可視化します。

#### 5. `ui.js` - 世界をインタラクティブに描画する
シミュレーションによって生成された膨大なデータを、ユーザーが直感的に理解できるように可視化します。
*   **ヘックスマップ描画**: D3.jsを使い、全てのヘックスを地形や植生に応じた色で塗り分けます。
*   **レイヤー表示**: 国境線、河川、街道、各種オーバーレイ（気候帯、人口、農業適性など）をボタン一つで表示・非表示に切り替えられます。
*   **情報ウィンドウ**: ヘックスをクリックすると、座標、人口、気候、経済状況などの詳細なデータがフローティングウィンドウに表示されます。
*   **支配領域のハイライト**: 主要都市をクリックすると、その都市が支配下に置く全ての領土が階層に応じて色分けされ、勢力範囲が一目で分かります。

#### 6. `infoWindow.js` - 詳細情報の可視化
ユーザーがヘックスをクリックした際に表示される詳細情報ウィンドウのコンテンツを生成・管理します。
*   **情報カードの生成**: 基本情報、環境、資源、産業、領地管理といったカテゴリごとにカード形式で情報を整理して表示します。
*   **サイドバー統計の更新**: 画面左側のサイドバーに表示される、世界全体の人口や国家ごとの統計情報を集計・更新します。
*   **凡例の管理**: 気温、降水量、気候帯、人口分布、魔物ランクなどのオーバーレイ表示に対応した凡例を動的に生成します。

#### 7. `GeoForge Data API` (Google Apps Script) - データ連携と通知
Google Sheetsをバックエンドデータベースとして利用し、データの永続化と外部通知機能を提供します。
*   **データ保存**: 生成されたヘックスデータや道路データをGoogle SheetsにJSON形式で保存します。
*   **データ読み込み**: 保存されたデータを読み込み、アプリケーションの初期化時に復元します。
*   **Discord通知**: 「強制再生成」などの重要なイベントが発生した際に、DiscordのWebhookを通じて管理者に通知を送信します。

### 産業と経済
産業構造を区分。「魔法」「ギルド」「宗教」が各産業に深く関わり、産業間の結びつきが強い。

1. **第一次産業**: 資源を得る
2. **第二次産業**: 資源を加工する
3. **第三次産業**: 人にサービスを提供する
4. **第四次産業**: 知識と情報を扱う
5. **第五次産業**: 社会を統治・創造する

#### 1. 第一次産業 - 自然資源の獲得
*   **農業**: 麦・野菜・果樹・薬草栽培。魔法農法や精霊の加護で収穫量増加。
*   **牧畜**: 牛・羊・魔物など。乳製品や毛皮、魔獣素材の供給。
*   **漁業**: 川・湖・海での漁。漁師ギルドとの協力。
*   **採掘**: 鉱石・宝石・魔鉱石。鍛冶屋や魔導具師の基盤。
*   **林業**: 木材・薬木・魔樹。建築資材や魔法触媒。

#### 2. 第二次産業 - 加工・製造
*   **鍛冶・工房**: 武器防具、魔導具、生活道具。職人ギルドが中心。
*   **錬金術**: 薬品・ポーション・触媒の製造。素材は第一次産業から供給。
*   **建築**: 城・都市・村の建設。石工ギルドや魔法建築師。
*   **織物・染色**: 羊毛や麻、魔獣皮を加工。貴族向け衣装から冒険者装備まで。

#### 3. 第三次産業 - サービス
*   **商業**: 市場・行商・ギルドによる流通。交易路や港町が発展。
*   **宿泊・飲食**: 酒場・宿屋・料理店。冒険者の拠点。
*   **交通**: 馬車・船・飛竜便。安全な移動を提供。
*   **医療・癒し**: 僧侶・薬師・治癒師。ポーション販売や施術。
*   **教育**: 魔法学校・剣術道場。知識と技能の伝承。

#### 4. 第四次産業 - 知識・情報
*   **魔法研究**: 魔術ギルド、大学、賢者の塔。新しい呪文や魔導理論の開発。
*   **戦略・軍事学**: 王国軍や冒険者ギルドの戦術研究。
*   **学問**: 歴史学・地理学・神話研究。世界観の体系化。
*   **情報収集**: 占い師・予言者・諜報組織。未来予測や敵国情報。

#### 5. 第五次産業 - 統治・創造
*   **王政・貴族政治**: 国家運営、外交、税制。
*   **宗教・信仰**: 神殿・教会・司祭。精神的支柱と社会秩序。
*   **芸術・文化**: 吟遊詩人、劇団、画家。物語や伝承を広める。
*   **職能ギルド**: 依頼仲介、世界の安全保障。産業横断的な存在。
*   **創造的魔法**: 新しい世界観や文明を生み出す力。

---

### 技術仕様

#### WorldMap データ構造 (メモリ最適化)
v2.3.2より、メモリ使用量を削減するために `WorldMap` クラスのデータ構造を大幅に最適化しました。

*   **Structure of Arrays (SoA)**:
    各ヘックスのプロパティを個別のオブジェクトとして保持するのではなく、プロパティごとに型付き配列 (TypedArray) を用意し、全ヘックス分のデータを連続したメモリ領域に格納しています。これにより、メモリオーバーヘッドを最小限に抑えています。

*   **Flyweight パターン**:
    個々のヘックスを操作するための `Hex` オブジェクトは、アクセス時にオンデマンドで生成される軽量なラッパーです。これらは永続的にキャッシュされないため、大量のオブジェクトによるメモリ圧迫を防ぎます。

*   **データ型一覧**:

    | カテゴリ | プロパティ | データ型 | 説明 |
    | :--- | :--- | :--- | :--- |
    | **座標** | `col`, `row` | `Uint16Array` | 座標 (0-65535) |
    | **フラグ** | `isWater`, `isAlluvial`, `hasSnow` | `Uint8Array` | フラグ (0 or 1) |
    | **地形・気候** | `elevation` | `Int16Array` | 標高 (m) |
    | | `ridgeFlow` | `Int16Array` | 稜線流量 |
    | | `temperature`, `precipitation_mm`, `precipitation`, `climate`, `flow` | `Float32Array` | 気温, 降水量, 気候値, 流量などの浮動小数点数 |
    | **Enum ID** | `climateZoneId`, `vegetationId`, `terrainTypeId`, `settlementId`, `manaRankId`, `resourceRankId`, `monsterRankId`, `nationId`, `roadLevel` | `Uint8Array` | 各種区分のID (0-255) |
    | **ポテンシャル** | `manaValue`, `agriPotential`, `forestPotential`, `miningPotential`, `fishingPotential`, `huntingPotential`, `pastoralPotential`, `livestockPotential` | `Float32Array` | 各種適性値 (0.0-1.0など) |
    | **統計** | `cultivatedArea`, `habitability` | `Float32Array` | 耕作面積, 居住適性 |
    | | `population` | `Uint32Array` | 人口 (0-4,294,967,295) |
    | **参照・関係** | `parentHexId`, `territoryId` | `Int32Array` | 親ヘックスID, 領土ID (-1はnull) |
    | | `distanceToParent`, `travelDaysToParent` | `Float32Array` | 親への距離, 移動日数 |
    | | `neighborsBuffer` | `Int32Array` | 隣接ヘックスID (固定長6/hex) |
    | **複合データ** | `landUse_*` | `Float32Array` | 土地利用内訳 (river, desert, barren, grassland, forest) |
    | | `industry`, `production`, `surplus`, `shortage`, `territoryData` | `Array` | 複雑なオブジェクトを格納する疎な配列 (Sparse Array) |

# 大陸生成

## 1. 地形の決定
- 大陸生成時に一度だけ実施する。
- 各ヘックスの標高と隣接ヘックスの標高により、地形区分と平坦度を決定する。

## 2. 気候の決定
- 大陸生成時に一度だけ実施する。
1. 各ヘックスの年間降水量と年平均気温（標高補正済み）を決定する。
2. 各ヘックスの気候区分を決定する。

**参考コード**
必要により適切なノイズを含めること。
```JavaScript
/**
 * GeoForge System: 12気候区分判定
 * 入力は「高度補正済みの年平均気温 T [°C]」「年間降水量 P [mm]」「標高 H [m]」
 * 出力は以下の12区分のいずれかの文字列:
 * - "氷雪気候"
 * - "ツンドラ気候"
 * - "亜寒帯湿潤気候"
 * - "亜寒帯乾燥気候"
 * - "ステップ気候"
 * - "砂漠気候(寒)"
 * - "砂漠気候(熱)"
 * - "地中海性気候"
 * - "温暖湿潤気候"
 * - "亜熱帯湿潤気候"
 * - "熱帯草原気候"
 * - "熱帯雨林気候"
 *
 * 判定方針（最小構成・月別データ不要）:
 * 1) 標高で高山/氷雪を優先判定（森林限界や氷雪域）
 * 2) 気温で寒帯・亜寒帯・温帯・亜熱帯/熱帯の帯域を決定
 * 3) 乾燥限界（簡易式）で乾燥帯（砂漠/ステップ）を判定
 * 4) 湿潤帯は降水量の閾値で温帯/亜熱帯/熱帯のサブタイプを割り当て
 */

function classifyClimate(T_mean, P_annual, H_m) {
  // ------------- 調整可能な閾値（世界観チューニング用） -------------
  const H_ice = 3600;     // 氷雪域の標高（m）: 高山・寒冷地での氷雪気候
  const H_alpine = 3000;  // 森林限界の代表値（m）: これ以上は樹木生育が困難（ツンドラ相当）

  // 乾燥限界（ケッペン準拠の簡易形）
  // 季節性を持たない最小構成として、定数オフセットC=140を採用（中庸）
  // Rbが高いほど乾燥閾が厳しくなり、乾燥帯の判定を避けやすい。
  const C = 140;
  const Rb = 20 * T_mean + C; // 乾燥限界（mm）

  // 熱帯・温帯・亜熱帯の湿潤/雨林判定用の基準値（目安）
  const P_rainforest = 2000;   // 熱帯雨林の代表閾（mm）
  const P_humid = 800;         // 温帯湿潤/亜熱帯湿潤の下限（mm）
  const P_mediterranean_upper = 700; // 地中海性の年降水量上限（mm）目安
  const P_steppe_low = Math.max(250, 0.5 * Rb); // ステップ下限の目安（安全側）

  // ------------- 1) 標高優先の寒冷域判定 -------------
  if (H_m >= H_ice || T_mean < -5) {
    return "氷雪気候";
  }
  if (H_m >= H_alpine || T_mean < 0.5) {
    // 森林限界以上 or 非常に低温 → ツンドラ
    return "ツンドラ気候";
  }

  // ------------- 2) 乾燥帯（砂漠/ステップ）判定 -------------
  // 乾燥帯の入口は年降水量と乾燥限界の比較で決定
  if (P_annual < 0.5 * Rb) {
    // 砂漠（熱/寒）は年平均気温で分岐
    return T_mean >= 18 ? "砂漠気候(熱)" : "砂漠気候(寒)";
  }
  if (P_annual < Rb) {
    return "ステップ気候";
  }

  // ------------- 3) 帯域（熱帯/亜熱帯/温帯/亜寒帯）と湿潤タイプ -------------
  // 亜寒帯（冷帯）: 寒冷な温帯の上位
  if (T_mean < -3) {
    // すでにツンドラ/氷雪でない寒冷湿潤域
    // 年降水量が乾燥限界以上なら湿潤、それ未満寄りなら乾燥
    return P_annual >= Rb ? "亜寒帯湿潤気候" : "亜寒帯乾燥気候";
  }

  // 温帯域（基準）
  if (T_mean >= -3 && T_mean < 18) {
    // 地中海性候補：温帯で比較的少雨（乾燥帯には入らない）
    if (P_annual <= P_mediterranean_upper && P_annual >= 0.5 * Rb) {
      return "地中海性気候";
    }
    // 十分湿潤なら温暖湿潤
    if (P_annual >= P_humid) {
      return "温暖湿潤気候";
    }
    // 湿潤下限に満たないが乾燥帯ではない場合は、温帯の中庸を温暖湿潤に吸収
    return "温暖湿潤気候";
  }

  // 亜熱帯・熱帯域（高温側）
  if (T_mean >= 18 && T_mean < 24) {
    // 乾燥帯に該当しない前提で、湿潤なら亜熱帯湿潤、比較的少雨なら熱帯草原に近い
    if (P_annual >= P_humid) {
      return "亜熱帯湿潤気候";
    }
    // 湿潤下限に満たないが乾燥帯ではない → 熱帯草原寄り
    return "熱帯草原気候";
  }

  // 熱帯（高温・多雨）
  if (T_mean >= 24) {
    // 多雨なら熱帯雨林、そうでなければ熱帯草原
    if (P_annual >= P_rainforest) {
      return "熱帯雨林気候";
    }
    return "熱帯草原気候";
  }

  // 万一のフォールバック（理論上到達しない）
  return "温暖湿潤気候";
}

// -------------- 例: テスト --------------
// console.log(classifyClimate(25, 2200, 50));   // 熱帯雨林気候
// console.log(classifyClimate(21, 1200, 100));  // 亜熱帯湿潤気候
// console.log(classifyClimate(12, 600, 200));   // 地中海性気候（温帯・少雨）
// console.log(classifyClimate(5, 900, 100));    // 温暖湿潤気候
// console.log(classifyClimate(-1, 700, 50));    // 亜寒帯湿潤気候
// console.log(classifyClimate(10, 300, 50));    // ステップ気候（乾燥）
// console.log(classifyClimate(16, 150, 50));    // 砂漠気候(寒)
// console.log(classifyClimate(28, 100, 50));    // 砂漠気候(熱)
// console.log(classifyClimate(-6, 500, 200));   // 氷雪気候
// console.log(classifyClimate(1, 500, 3200));   // ツンドラ気候（高標高）
```

3. 各ヘックスの保水力を決定する。

### 地形：地形保水基準
- 深海：-
- 海洋：-
- 湖沼：-
- 平地：0.60
- 丘陵：0.50
- 山地：0.40
- 山岳：0.30

### 気候区分：気候保水基準：蒸発散係数
- 砂漠気候(寒)：0.1：0.85
- ツンドラ気候：0.35：0.55
- 亜寒帯湿潤気候：0.65：0.40
- ステップ気候：0.25：0.75
- 地中海性気候：0.55：0.55
- 温暖湿潤気候：0.65：0.45
- 砂漠気候(熱)：0.08：0.95
- 熱帯草原気候：0.40：0.65
- 熱帯雨林気候：0.75：0.35
- 亜熱帯湿潤気候：0.60：0.50
- 亜寒帯乾燥気候：0.30：0.70
- 氷雪気候：0.12：0.80

### 保水力の算定式
`保水力 = clip01((0.6 * 地形保水基準 + 0.4 * 気候保水基準) * (1 - 0.7 * 蒸発散係数))`

**参考コード**
```JavaScript
// 水源発生確率を計算する関数
// 入力: 標高 E [m], 降水量 P [mm], 保水力 R [0..1]
// 出力: 0..1 の確率
function waterSourceProbability(E, P, R, {
  Emax = 4500,   // 最大標高 [m]
  P_half = 800,  // 降水量の半飽和定数 [mm]
  alpha = 1.2,   // 降水の閾値強調係数
  beta = 0.7     // 標高寄与の指数
} = {}) {
  const clip01 = x => Math.max(0, Math.min(1, x));

  // 標高の正規化と源頭寄与
  const E_norm = clip01(E / Emax);
  const E_src = Math.pow(E_norm, beta); // 標高寄与

  // 降水の飽和（ミカエリス・メンテン型）
  const P_eff = P / (P + P_half);

  // 保水・標高のブースト因子（0.5〜1.0, 0.4〜1.0）
  const retentionBoost = 0.5 + 0.5 * R;
  const elevationBoost = 0.4 + 0.6 * E_src;

  // 最終確率
  const prob = Math.pow(P_eff, alpha) * retentionBoost * elevationBoost;
  return clip01(prob);
}

// 例: 標高 1200m, 降水 900mm, 保水力 0.43
const p = waterSourceProbability(1200, 900, 0.43);
console.log(p); // 0..1 の値を返す
```

## 3. 河川を生成する。

### 河川水域算定アルゴリズム
- 水域面積の算定方法を具体化します。
- 各ヘックスの面積は8660ha、対辺間距離は10kmです。
- 区間流線長は、どの辺からどの辺へ流れたかにより決まります。
- 対辺間を流れる場合の直線距離は10km、隣接辺へ流れ出る場合の直線距離は5km、2つ目の辺へ流れ出る場合の直線距離は8.66km、水源地の場合は5km、これに上流と下流の高低差と平坦度を使って蛇行度を見積り、実流水区間長(km)を決定します。
- 流量は、水源地ヘックスから流れ出る流量を0.5㎥/sとし、各ヘックスは上流側の辺（流入辺）流量（複数の進入部がある場合は当該ヘックスで合流する）に保水力と降水量による基本増加量を加算し、下流側の辺（流出辺）流量を求めます。
- 各ヘックスは、流量と高低差、実流水区間長から流速、断面を決定し水域面積を出力します。

```JavaScript
/**
 * 水域面積算定
 * 入力: 流入流量 Qin [m3/s], 降水量 P [mm], 保水力 R [0..1],
 *       高低差 dH [m], 平坦度 flatness [0..1],
 *       流線タイプ type ("opposite","second","source")
 * 出力: 水域面積 [ha]
 */

function calcWaterArea({
  Qin, P, R, dH, flatness, type
}) {
  const clip01 = x => Math.max(0, Math.min(1, x));

  // --- 区間直線距離 ---
  let L_straight = 10;
  if (type === "second") L_straight = 8.66;
  else if (type === "source") L_straight = 5;

  // --- 蛇行度補正 ---
  const meanderFactor = 1 + (dH / 1000) * (1 - flatness);
  const L_actual = L_straight * meanderFactor; // km

  // --- 流量計算 ---
  const k = 0.00005; // 調整係数
  const dQ = k * P * R; // 降水・保水寄与
  const Qout = Qin + dQ;

  // --- 流速・断面 ---
  // 幅は平坦度に比例 (10–100m)
  const width = 10 + 90 * flatness;
  // 水深は流量と高低差から近似
  const depth = Math.max(0.5, (Qout / 5) + dH / 500);
  const A = width * depth; // m2

  const v = Qout / A; // m/s

  // --- 水域面積算定 ---
  // 区間長[km] → m に変換
  const WaterArea_m2 = (L_actual * 1000) * width;
  const WaterArea_ha = WaterArea_m2 / 10000;

  return {
    L_actual_km: L_actual,
    Qout,
    v,
    width,
    depth,
    WaterArea_ha
  };
}

// --- 使用例 ---
const result = calcWaterArea({
  Qin: 0.5, P: 900, R: 0.43,
  dH: 50, flatness: 0.6, type: "opposite"
});

console.log(result);
```
異常な値にならないように抑制が必要
**1000ha以上の河川水域は、湖沼ではないか？**

```JavaScript
/**
 * 河口・デルタ向け水域面積算定（タイプ別に分離）
 * 入力:
 *  - hexHa: ヘックス面積[ha]
 *  - L_km: 実流長[km]（河口でも8.66〜10を採用可）
 *  - Q: 累積流量[m3/s]
 *  - flatness[0..1], oceanicity[0..1], R[0..1] 保水力
 *  - tidalRange[m] 潮汐レンジ（例：1〜4m）
 *  - isRiverMouth: 河口フラグ
 * 出力: { channelHa, deltaHa, marshHa, lagoonHa, waterTotalHa }
 */
function waterAreasRiverMouth({
  hexHa = 8660,
  L_km = 8.66,
  Q,
  flatness,
  oceanicity,
  R,
  tidalRange = 2.0,
  isRiverMouth = false
}) {
  const clip01 = x => Math.max(0, Math.min(1, x));
  const L_m = L_km * 1000;

  // 幅・深さの経験式（初期係数）
  const a = 2.5, b = 0.5;     // w = a * Q^b
  const c = 0.25, f = 0.4;    // d = c * Q^f
  const w_m = Math.max(15, a * Math.pow(Q, b));
  const d_m = Math.max(1.0, c * Math.pow(Q, f));

  // 河道面積
  const channelHa_raw = (L_m * w_m) / 1e4;

  // 河口・デルタ拡張係数
  const tideFactor = clip01(tidalRange / 3.0);               // 0〜1
  const flatWet = clip01(0.6 * flatness + 0.4 * R);          // 0〜1
  const coastFactor = clip01(oceanicity);                     // 0〜1

  // デルタ・干潟面積（河道の数倍に拡張）
  // 河口なら強化、内陸なら抑制
  const deltaMultiplier = isRiverMouth
    ? 1.0 + 4.0 * (0.5 * tideFactor + 0.3 * flatWet + 0.2 * coastFactor)
    : 0.5 + 1.0 * flatWet;

  const deltaHa_raw = channelHa_raw * deltaMultiplier;

  // 湿地（塩湿地・感潮湿地）
  const marshHa_raw = channelHa_raw * (0.8 + 2.5 * flatWet) * (0.5 + 0.5 * coastFactor);

  // 潟湖（lagoon）：潮汐＋海洋性が高く、平坦で保水力が高いほど成立
  const lagoonFrac = isRiverMouth ? 0.05 + 0.25 * (0.4 * tideFactor + 0.4 * coastFactor + 0.2 * flatWet) : 0;
  const lagoonHa_raw = hexHa * lagoonFrac;

  // 上限（cap）
  const channelCapFrac = isRiverMouth ? 0.20 : 0.10;  // 河道の面積上限
  const deltaCapFrac   = isRiverMouth ? 0.60 : 0.20;  // デルタ・干潟の上限
  const marshCapFrac   = isRiverMouth ? 0.50 : 0.30;  // 湿地の上限
  const lagoonCapFrac  = isRiverMouth ? 0.40 : 0.10;  // 潟湖の上限
  const totalCapFrac   = isRiverMouth ? 0.95 : 0.50;  // 総水域の上限

  let channelHa = Math.min(channelHa_raw, hexHa * channelCapFrac);
  let deltaHa   = Math.min(deltaHa_raw,   hexHa * deltaCapFrac);
  let marshHa   = Math.min(marshHa_raw,   hexHa * marshCapFrac);
  let lagoonHa  = Math.min(lagoonHa_raw,  hexHa * lagoonCapFrac);

  // 総面積の上限調整（超過時は比率で縮小）
  let waterTotalHa = channelHa + deltaHa + marshHa + lagoonHa;
  const maxTotal = hexHa * totalCapFrac;
  if (waterTotalHa > maxTotal) {
    const scale = maxTotal / waterTotalHa;
    channelHa *= scale; deltaHa *= scale; marshHa *= scale; lagoonHa *= scale;
    waterTotalHa = maxTotal;
  }

  return {
    channelHa: Math.round(channelHa),
    deltaHa: Math.round(deltaHa),
    marshHa: Math.round(marshHa),
    lagoonHa: Math.round(lagoonHa),
    waterTotalHa: Math.round(waterTotalHa)
  };
}
```

## 4. 植生を決定する。

### 植生区分
- 砂漠：乾燥地帯、農耕不可、交易路・鉱物資源に強み。乾燥指標が高、肥沃度低、平坦でも可
- ステップ：乾燥草原、遊牧・交易路に強み、農耕は限定的。乾燥指標中、肥沃度中、火事係数中
- サバンナ：疎林草原、牧畜・狩猟・交易に適する。高温＋中乾燥、火事係数高、土壌水分保持は中
- 草原：農耕・牧畜両立、交通容易、人口集積に適する。温帯/亜寒帯＋中降水、肥沃度高、排水良好
- 温帯林：四季変化、木材・狩猟資源豊富、農耕と共存可能。温帯＋降水充分、肥沃度中～高、排水中
- 亜寒帯林：タイガ、針葉樹中心、木材・毛皮資源、農耕制約あり。低温＋降水充分、標高高め
- 熱帯雨林：高生産性だが伐採困難、果実・薬草・病害リスク大。高温＋高降水、排水過剰でなく、火事係数低
- 湿地：農耕困難だが魚介・薬草資源豊富、交通制約大。低平坦度＋高水域近接＋排水不良/氾濫高
- 沿岸植生：海岸砂丘・マングローブ・潮間帯、漁業・塩資源・港湾立地に直結。海岸近接（距岸距離の減衰）
- ツンドラ：寒帯草原、苔・低木主体、農耕不可、狩猟・遊牧中心。最暖期低温＋高標高/高緯度、土壌凍結（代替に低温で代用）
- アルパイン（高山植生）：森林限界上、低木・草本主体、資源乏しいが鉱物・水源あり。標高森林限界超過
- 荒れ地：半乾燥・痩せ地、低生産性だが鉱物・放牧に利用可能。低肥沃度＋高傾斜（平坦度低）＋降水不足（乾燥では砂漠未満の荒地）
- 氷雪帯：高標高＋低温、植物はなく氷雪覆われた地形

### 植生区分判定のためのパラメータ
- 年平均気温
- 年間降水量
- 標高
- 海洋/湖沼/河川水域面積
- 地形平坦度（隣接ヘックス標高、稜線レベル）
- 土壌肥沃度：0–1
- 乾燥指数：年間降水量 / (20 * 年平均気温 + 140)
- 距岸距離（海からの距離）／海洋性係数

**参考コード**
植生分布は毎起動時に計算するため、ノイズを含めない。
```JavaScript
/**
 * 植生分布計算（保水力を含む）
 * 入力: 年平均気温 T [°C], 
 *       年間降水量 P [mm], 
 *       標高 H [m],
 *       水域面積 waterHa [ha], 
 *       平坦度 flatness [0–1],
 *       土壌肥沃度 soilFert [0–1], 
 *       乾燥指数 D,
 *       距岸距離 coastalDist [km], 
 *       海洋性係数 oceanicity [0–1],
 *       保水力 R [0–1]
 * 出力: 各植生区分の面積 [ha]
 */

function allocateVegetation({
  T, P, H, waterHa,
  flatness, soilFert, D,
  coastalDist, oceanicity,
  R // 保水力
}) {
  const hexAreaHa = 8660;
  const landHa = Math.max(0, hexAreaHa - waterHa);

  // 適性スコア初期化
  const s = {
    desert: 0, wasteland: 0, grassland: 0, wetland: 0,
    temperateForest: 0, subarcticForest: 0, tropicalRainforest: 0,
    alpine: 0, tundra: 0, savanna: 0, steppe: 0, coastal: 0,
    iceSnow: 0
  };

  // --- 植生適性スコア計算 ---
  // 氷雪帯: 高標高 or 極低温
  if (T <= -5 || H >= 4000) {
    s.iceSnow = 1.2;
  }

  // 砂漠: 乾燥指数 <0.5
  if (D < 0.5 && s.iceSnow === 0) {
    s.desert = (0.5 - D) * (T >= 18 ? 1.0 : 0.7) * (1 - R);
  }

  // 荒れ地: 土壌肥沃度が低い & 降水不足
  if (soilFert < 0.3 && P < 400) {
    s.wasteland = 0.6 * (1 - 0.5 * R);
  }

  // 草原: 中程度の降水 & 平坦度高
  if (D >= 1 && P >= 400 && P < 1200) {
    s.grassland = 0.7 * flatness * (0.5 + 0.5 * R);
  }

  // 湿地: 平坦度高 & 排水不良
  if (flatness > 0.7 && (P > 1200 || oceanicity > 0.6)) {
    s.wetland = 0.8 * (0.5 + 0.5 * R);
  }

  // 温帯林: T 5–18℃ & P充分
  if (T >= 5 && T < 18 && P >= 800) {
    s.temperateForest = 0.8 * soilFert * (0.5 + 0.5 * R);
  }

  // 亜寒帯林: T -3〜5℃ & P充分
  if (T >= -3 && T < 5 && P >= 600) {
    s.subarcticForest = 0.7 * (0.5 + 0.5 * R);
  }

  // 熱帯雨林: T ≥24℃ & P ≥2000
  if (T >= 24 && P >= 2000) {
    s.tropicalRainforest = 0.9 * (0.5 + 0.5 * R);
  }

  // アルパイン: 標高 ≥3000m
  if (H >= 3000 && s.iceSnow === 0) {
    s.alpine = 1.0 * (0.5 + 0.5 * R);
  }

  // ツンドラ: T <2℃ または 標高 ≥2400m
  if ((T < 2 || H >= 2400) && s.iceSnow === 0) {
    s.tundra = 0.7 * (0.5 + 0.5 * R);
  }

  // サバンナ: T ≥18℃ & D 0.5–1
  if (T >= 18 && D >= 0.5 && D < 1) {
    s.savanna = 0.6 * (0.7 + 0.3 * R);
  }

  // ステップ: D 0.5–1 & P <800
  if (D >= 0.5 && D < 1 && P < 800) {
    s.steppe = 0.6 * (1 - 0.5 * R);
  }

  // 沿岸植生: 海岸近接
  if (coastalDist < 20 || oceanicity > 0.7) {
    s.coastal = 0.7 * (0.5 + 0.5 * R);
  }

  // --- 正規化して面積配分 ---
  const sum = Object.values(s).reduce((a, b) => a + b, 0);
  const areas = {};
  if (sum === 0) {
    areas.grassland = landHa; // フォールバック
  } else {
    for (const [k, v] of Object.entries(s)) {
      areas[k] = Math.round((v / sum) * landHa);
    }
  }
  areas.water = waterHa;

  return areas;
}

// --- 使用例 ---
const result = allocateVegetation({
  T: 22, P: 900, H: 1200,
  waterHa: 200, flatness: 0.6,
  soilFert: 0.5, D: 900 / (20 * 22 + 140),
  coastalDist: 30, oceanicity: 0.4,
  R: 0.43 // 保水力
});

console.log(result);
```